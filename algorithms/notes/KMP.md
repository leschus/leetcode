# 字符串匹配与KMP算法

问题描述: 从主串s中寻找模式串t第一次出现的位置.

## 暴力匹配

```cpp
int Index(string s, string t) {
  int i = 0, j = 0; // 下标从0开始
  while (i < s.size() && j < t.size()) {
    if (s[i] == t[j]) {
      i++; j++;
    } else {
      i = i - j + 1;
      j = 0;
    }
  }
  if (j == t.size()) {
    return i - t.size();
  } else {
    return -1;
  }
}
```

暴力模式匹配算法的时间复杂度为`O(nm)`, 其中n和m分别是主串s和模式串t的长度.

对于模式串为`"aaaab"`, 主串为`"aaaaaaaaab"`的情况, 每一轮比较都要比到模式串的最后一个字符, 即比较`5`次; 一轮比较最后发现不匹配之后, 再执行回溯, 共需回溯`5`轮; 加上最开始的一轮, 共计`6`轮. 总共比较次数为`6 × 5 = 30`次.

## 改进的模式匹配算法: KMP算法

### 了解概念

首先理解字符串中的三个概念:
* **前缀**: 字符串的任意头部子串(不包括字符串本身);
* **后缀**: 字符串的任意尾部子串(不包括字符串本身);
* **最长公共前后缀**: 由字符串的前缀集合和后缀集合中的公共元素所组成的子串集合中, 长度最大的那个子串;

例如, 字符串`"ababa"`的前缀集合为: `{"a", "ab", "aba", "abab"}`, 后缀集合为`{"a", "ba", "aba", "baba"}`, 两个集合的公共元素有`"a"`和`"aba"`. 从而字符串的最长公共前后缀为`"aba"`.

一个长度为`m`的模式串, 共有`m`个头部子串. 这些头部子串的最长公共前后缀的长度被称作`部分匹配值(Partial Match Value)`.

以模式串`"ababa"`为例:

* 长度为1的头部子串为`"a"`, 其最长公共前后缀为`""`, 即PM值为0.
* 长度为2的头部子串为`"ab"`, 其最长公共前后缀也为`""`, 即PM值为0.
* 长度为3的头部子串为`"aba"`, 其最长公共前后缀为`"a"`, 即PM值为1.
* 长度为4的头部子串为`"abab"`, 其最长公共前后缀为`"ab"`, 即PM值为2.
* 长度为5的头部子串为`"ababa"`, 其最长公共前后缀为`"aba"`, 即PM值为3.

根据上述5个部分匹配值可以得到一张模式串`"ababa"`的部分匹配值表:

| 编号 | 0 | 1 | 2 | 3 | 4 |
| ---- |---|---|---|---|---|
| 字符 | a | b | a | b | a |
| PM值 | 0 | 0 | 1 | 2 | 3 |

当主串为`"ababcababa"`时, 第一轮比对会发现主串中的`'c'`和模式串中的`'a'`不匹配:


| 主串 | a | b | a | b | c | a | b | a | b | a |
|:----:|---|---|---|---|---|---|---|---|---|---|
|模式串| a✔️ | b✔️ | a✔️ | b✔️ | a❌ |

按照暴力匹配算法, 这将导致第二轮模式串将右移一个单位重新与主串对应位置元素进行比对.

由于第一轮比对中, 前四个元素均是匹配的, 即`"abab"`, 从而第二轮比对首先得要求`"abab"`的长度为3的尾部子串`"bab"`务必与其长度为3的尾部首部子串`"aba"`匹配. 显然, 这是不被满足的. 根据部分匹配值表也可看出: `"abab"`对应的PM值只有2, 因而不存在长度为3的公共前后缀.

这说明, 暴力求解算法的第二轮比对其实是多余的. 那么, 可否消除这轮多余的比对呢?

答案是: 可以.

这也正是KMP算法思路的由来.

上述例子中, 我们分析得到下一轮(第二轮)比对必然失败的结论, 仅仅借助了两样前提:
1. 本轮比对的结果. 即本轮(第一轮)比对虽然失败, 但它成功匹配了模式串的前四个字符, 由此构成的模式串的头部子串为`"abab"`;
2. 模式串的部分匹配值表. 从表中得出模式串的长度为4的头部子串的PM值为2. 而下一轮(第二轮)模式串若右移一位将要求模式串的长度为4的头部子串具有长度为3的公共前后缀, 该要求无法被满足.

借助同样的思路, 我们可以计算出下一轮模式串应当右移多少个单位才合适. 先给出公式:

$$ 移动位数 = 本轮成功匹配的字符数 - 对应的PM值 $$

(公式解释: 🏳️)

因此, 上例中进入第二轮之前模式串应当右移的位数为: $4-2=2$.

从而第二轮的比对情况为:

| 主串 | a | b | a | b | c | a | b | a | b | a |
|:----:|---|---|---|---|---|---|---|---|---|---|
|模式串|   |   | a✔️ | b✔️ | a❌ | b | c |

进入第三轮之前模式串应当右移位数为: $2-0=2$.

从而第三轮的比对情况为:

| 主串 | a | b | a | b | c | a | b | a | b | a |
|:----:|---|---|---|---|---|---|---|---|---|---|
|模式串|   |   |   |  | a❌ | b | a | b | a |

进入第四轮之前模式串应当右移位数为: $0-(-1)=1$

注意⚠️: 某一轮成功匹配的字符数为0时, 其对应的PM值应当是-1 (此条没有在部分匹配值表中列出).

从而第四轮的比对情况为:

| 主串 | a | b | a | b | c | a | b | a | b | a |
|:----:|---|---|---|---|---|---|---|---|---|---|
|模式串|   |   |   |  |  | a✔️ | b✔️ | a✔️ | b✔️ | a✔️ |

即, 第四轮比对模式串匹配成功.

### 实现KMP算法

将部分匹配值表用数组PM存储, 下标从0开始. 则`PM[i]`表示某一轮成功匹配`i+1`个字符时对应的PM值.

以暴力求解算法代码为基础, 每一轮比对到失配的情形出现时算作该轮比对结束, 则该轮的成功匹配字符数可以用`j`表示, 对应的PM值为`PM[j-1]`.

由此, 下一轮比对开始前模式串的右移位数`move`计算式为:
$$ move = j-PM[j-1]$$

为了避免`j`等于0时, `PM[-1]`非法, 可将PM表元素集体右移一位, 并在下标0处填入-1. 这表示某一轮成功匹配字符个数为0时, 应当将模式串右移1位 (参考上节示例中的第四轮). 将经过这一处理的PM数组换个称呼, 叫作: next数组.

例如, 针对模式串`"ababa"`, 其next数组内容为:

| index | 0 | 1 | 2 | 3 | 4 |
| :----: |---|---|---|---|---|
| next | -1 | 0 | 0 | 1 | 2 |

计算式更新为:
$$move=j-next[j]$$

进一步地, "模式串右移"这一操作体现在代码上就是更新`j`的值. 具体地说, 是将`j`值更新为`j - move`.

从而, 一轮结束后, `j`值更新公式为:
$$j=j-move=j-(j-next[j])=next[j]$$

#### 生成next数组:

```cpp
// 根据模式串t生成next数组
vector<int> generate_next(string t) {
  vector<int> next(t.size());
  next[0] = -1;
  int i = 0, j = -1;
  while (i < t.size()) {
    if (j == -1 || t[i] == t[j]) {
      i++; j++;
      next[i] = j;
    } else {
      j = next[j];
    }
  }
  return next;
}
```
思路解析: 🏳️

#### 基于next数组实现KMP算法:
```cpp
int Index_KMP(string s, string t) {
  vector<int> next = generate_next(t);
  for (int x: next) cout << x << " ";
  cout << endl;
  int i = -1, j = -1;
  int len1 = s.size(), len2 = t.size();
  // 注意: 直接将变量i和s.size()比较会有问题, 因为s.size()的返回类型size_t没有
  // 符号, 因此将int型的-1和size_t类型值进行比较, 将发生隐式向上类型转换, 导致
  // 参与比较的i值实际为UINT_MAX. ==>由此导致while()循环根本就不会进入!!
  while (i < len1 && j < len2) {
    if (j == -1 || s[i] == t[j]) {
      i++; j++;
    } else {
      j = next[j];
    }
  }
  if (j == len2) {
    return i - len2;
  } else {
    return -1;
  }
}
```
思路解析: 🏳️